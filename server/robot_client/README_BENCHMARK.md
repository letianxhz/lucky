# 购买道具压测文档

## 压测目的

通过机器人并发测试购买道具功能，找出性能热点并提出优化方案。

## 使用方法

### 方法 1: 使用压测脚本（推荐）

```bash
cd lucky/server
./robot_client/run_benchmark.sh [机器人数量] [每个机器人请求数]

# 示例：100个机器人，每个机器人10个请求
./robot_client/run_benchmark.sh 100 10
```

### 方法 2: 修改代码运行

在 `robot_client/main.go` 中设置：

```go
var (
    benchmarkMode     = true   // 开启压测模式
    benchmarkRobots   = 100    // 机器人数量
    benchmarkRequests = 10    // 每个机器人请求数
)
```

然后运行：

```bash
cd lucky/server
go run ./robot_client
```

## 性能监控

### 启动性能监控（在另一个终端）

```bash
cd lucky/server
./robot_client/monitor_performance.sh
```

### 查看服务日志

```bash
# Game 服务日志
tail -f logs/game.log

# Gate 服务日志
tail -f logs/gate.log

# Web 服务日志
tail -f logs/web.log
```

### 使用 Go 工具分析

```bash
# 查看 goroutine 信息
go tool pprof http://localhost:20011/debug/pprof/goroutine

# 查看 CPU 性能
go tool pprof http://localhost:20011/debug/pprof/profile

# 查看内存使用
go tool pprof http://localhost:20011/debug/pprof/heap
```

## 压测指标

压测会输出以下指标：

- **总请求数**: 所有机器人发送的总请求数
- **成功请求**: 成功处理的请求数和百分比
- **失败请求**: 失败的请求数和百分比
- **总耗时**: 压测总耗时（秒）
- **QPS**: 每秒处理的请求数
- **平均延迟**: 平均响应时间（毫秒）
- **最大延迟**: 最大响应时间（毫秒）
- **最小延迟**: 最小响应时间（毫秒）

## 性能热点分析

### 1. 数据库操作

**潜在问题**:
- 每次购买都需要查询玩家数据
- 没有使用缓存
- 可能存在数据库连接池瓶颈

**优化方案**:
- 使用 Redis 缓存玩家数据
- 实现玩家数据的内存缓存（Actor 级别）
- 优化数据库查询，使用索引
- 批量操作减少数据库交互

### 2. 消息序列化/反序列化

**潜在问题**:
- Protobuf 序列化/反序列化开销
- 消息路由开销

**优化方案**:
- 使用对象池复用消息对象
- 优化 Protobuf 编码
- 减少不必要的消息字段

### 3. Actor 消息处理

**潜在问题**:
- Actor 消息队列可能成为瓶颈
- 单个 Actor 处理能力有限

**优化方案**:
- 增加 Actor 并发处理能力
- 使用异步处理非关键路径
- 实现消息批处理

### 4. 网络 I/O

**潜在问题**:
- 网络连接数限制
- TCP 连接建立开销

**优化方案**:
- 使用连接池
- 实现长连接复用
- 优化网络缓冲区大小

### 5. 日志输出

**潜在问题**:
- 大量日志输出影响性能
- 日志 I/O 阻塞

**优化方案**:
- 使用异步日志
- 减少日志级别（压测时使用 ERROR 级别）
- 使用结构化日志并批量写入

## 优化建议

### 短期优化（快速见效）

1. **添加缓存层**
   ```go
   // 在 Actor 中缓存玩家数据
   type actorPlayer struct {
       playerData *PlayerData // 缓存玩家数据
       cacheTime  time.Time   // 缓存时间
   }
   ```

2. **减少日志输出**
   - 压测时关闭 DEBUG 日志
   - 使用采样日志（每 N 条记录一次）

3. **优化错误处理**
   - 避免在热路径中使用 defer
   - 减少不必要的错误检查

### 中期优化（需要重构）

1. **实现数据缓存**
   - 使用 Redis 缓存玩家数据
   - 实现本地内存缓存

2. **批量处理**
   - 批量查询数据库
   - 批量更新数据

3. **异步处理**
   - 非关键操作异步处理
   - 使用消息队列处理耗时操作

### 长期优化（架构层面）

1. **分片策略**
   - 按玩家ID分片
   - 分布式缓存

2. **读写分离**
   - 读操作使用从库
   - 写操作使用主库

3. **微服务拆分**
   - 将购买逻辑独立为服务
   - 使用专门的商品服务

## 压测建议

1. **逐步增加压力**
   - 从 10 个机器人开始
   - 逐步增加到 100、500、1000
   - 观察性能曲线

2. **监控关键指标**
   - CPU 使用率
   - 内存使用
   - Goroutine 数量
   - 响应时间分布

3. **对比优化前后**
   - 记录优化前的基准数据
   - 实施优化后再次压测
   - 对比性能提升

## 示例压测结果分析

```
========== 压测结果统计 ==========
总请求数: 1000
成功请求: 980 (98.00%)
失败请求: 20 (2.00%)
总耗时: 15.32 秒
QPS: 65.27 请求/秒
平均延迟: 45.23 毫秒
最大延迟: 234 毫秒
最小延迟: 12 毫秒
====================================
```

**分析**:
- QPS 65 偏低，需要优化
- 最大延迟 234ms 较高，可能存在瓶颈
- 失败率 2% 需要关注

**优化方向**:
1. 分析最大延迟的请求，找出慢路径
2. 优化数据库查询
3. 增加缓存减少数据库压力





