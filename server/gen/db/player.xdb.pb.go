// Code generated by protoc-gen-xdb. DO NOT EDIT.
// versions:
//	protoc-gen-xdb v1.0.0

package db

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"lucky/server/pkg/xdb"
	proto "google.golang.org/protobuf/proto"
)

// Field constants for Player
const (
	PlayerFieldPlayerId xdb.Field = iota
	PlayerFieldName
	PlayerFieldLevel
	PlayerFieldExp
	PlayerFieldCtime
	PlayerFieldMtime
)

// PlayerPK 主键
type PlayerPK struct {
	PlayerId int64
}

func (pk *PlayerPK) Source() *xdb.Source {
	return _PlayerSource
}

func (pk *PlayerPK) String() string {
	return fmt.Sprintf("player:%v", pk.PlayerId)
}

func (pk *PlayerPK) HashGroup() int {
	return int(pk.PlayerId % 16)
}

func (pk *PlayerPK) Empty() bool {
	return pk.PlayerId == 0
}

func (pk *PlayerPK) PrefixOf(key xdb.Key) bool {
	_, ok := key.(*PlayerPK)
	if !ok {
		return false
	}
	// TODO: 实现前缀匹配逻辑
	return false
}

func (pk *PlayerPK) Full() bool {
	return pk.PlayerId != 0
}

func (pk *PlayerPK) FetchFilter() interface{} {
	filter := make(map[string]interface{})
	if pk.PlayerId != 0 {
		filter["player_id"] = pk.PlayerId
	}
	return filter
}

// PlayerRecord 记录结构体
type PlayerRecord struct {
	xdb.Header
	Player
}

func (r *PlayerRecord) Source() *xdb.Source {
	return _PlayerSource
}

func (r *PlayerRecord) XId() string {
	return fmt.Sprintf("player:%v", r.PlayerId)
}

func (r *PlayerRecord) Lifecycle() xdb.Lifecycle {
	return r.Header.Lifecycle()
}

func (r *PlayerRecord) Snapshoot() interface{} {
	return &r.Player
}

func (r *PlayerRecord) XVersion() int64 {
	return 0
}

func (r *PlayerRecord) GetHeader() *xdb.Header {
	return &r.Header
}

func (r *PlayerRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(&r.Player)
}

func (r *PlayerRecord) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, &r.Player)
}

func (r *PlayerRecord) String() string {
	return fmt.Sprintf("PlayerRecord{%s:%v}", "player_id", r.PlayerId)
}

func (r *PlayerRecord) Init(ctx context.Context, data interface{}) error {
	proto, ok := data.(*Player)
	if !ok {
		return fmt.Errorf("invalid data type")
	}
	r.Player = *proto
	r.Header.Init(xdb.LifecycleNew)
	return nil
}

func (r *PlayerRecord) Update(ctx context.Context, changes interface{}, fs xdb.FieldSet) error {
	proto, ok := changes.(*Player)
	if !ok {
		return fmt.Errorf("invalid changes type")
	}
	if fs.Contains(PlayerFieldPlayerId) {
		r.PlayerId = proto.PlayerId
	}
	if fs.Contains(PlayerFieldName) {
		r.Name = proto.Name
	}
	if fs.Contains(PlayerFieldLevel) {
		r.Level = proto.Level
	}
	if fs.Contains(PlayerFieldExp) {
		r.Exp = proto.Exp
	}
	if fs.Contains(PlayerFieldCtime) {
		r.Ctime = proto.Ctime
	}
	if fs.Contains(PlayerFieldMtime) {
		r.Mtime = proto.Mtime
	}
	return nil
}

func (r *PlayerRecord) Delete(ctx context.Context) bool {
	return r.Header.MarkAsDeleted(ctx)
}

func (r *PlayerRecord) Commit(ctx context.Context) (xdb.Commitment, xdb.FieldSet) {
	commitment := &PlayerCommitment{
		data:      &r.Player,
		changes:   r.Header.Changes(),
		lifecycle: r.Header.Lifecycle(),
	}
	return commitment, r.Header.Changes()
}

func (r *PlayerRecord) Committing() bool {
	return r.Header.Committing()
}

func (r *PlayerRecord) Dirty() bool {
	return r.Header.Dirty()
}

func (r *PlayerRecord) SavingIndex() int32 {
	return r.Header.SavingIndex
}

func (r *PlayerRecord) SetSavingIndex(idx int32) {
	r.Header.SavingIndex = idx
}

var _PlayerSource = &xdb.Source{
	ProtoType:  reflect.TypeOf((*Player)(nil)).Elem(),
	RecordType: reflect.TypeOf((*PlayerRecord)(nil)).Elem(),
	PKType:     reflect.TypeOf((*PlayerPK)(nil)).Elem(),
	Namespace:  "player",
	DriverName: "none",
	TableName:  "player",
	KeySize:    1,

	PKCreator: func(args []interface{}) (xdb.PK, error) {
		if len(args) < 1 {
			return nil, fmt.Errorf("invalid args count")
		}
		return &PlayerPK{
			PlayerId: args[0].(int64),
		}, nil
	},

	PKOf: func(obj interface{}) xdb.PK {
		// 支持 Record 类型
		if r, ok := obj.(*PlayerRecord); ok {
			return &PlayerPK{
				PlayerId: r.PlayerId,
			}
		}
		// 支持 proto 类型
		if p, ok := obj.(*Player); ok {
			return &PlayerPK{
				PlayerId: p.PlayerId,
			}
		}
		// 支持 Commitment 类型
		if c, ok := obj.(*PlayerCommitment); ok {
			return &PlayerPK{
				PlayerId: c.data.PlayerId,
			}
		}
		return nil
	},

	PKComparator: func(a, b interface{}) int {
		pk1 := a.(*PlayerPK)
		pk2 := b.(*PlayerPK)
		if pk1.PlayerId < pk2.PlayerId {
			return -1
		} else if pk1.PlayerId > pk2.PlayerId {
			return 1
		}
		return 0
	},

	CreateCommitment: func() xdb.Commitment {
		return &PlayerCommitment{}
	},
}

// PlayerCommitment 提交对象
type PlayerCommitment struct {
	data      *Player
	changes   xdb.FieldSet
	lifecycle xdb.Lifecycle
}

func (c *PlayerCommitment) Source() *xdb.Source {
	return _PlayerSource
}

func (c *PlayerCommitment) Merge(other xdb.Commitment) bool {
	otherC, ok := other.(*PlayerCommitment)
	if !ok {
		return false
	}
	c.changes = c.changes.Union(otherC.changes)
	return true
}

func (c *PlayerCommitment) Changes() xdb.FieldSet {
	return c.changes
}

func (c *PlayerCommitment) PrepareWrite() (interface{}, interface{}) {
	return c.data, nil
}

func (c *PlayerCommitment) Lifecycle() xdb.Lifecycle {
	return c.lifecycle
}

func (c *PlayerCommitment) Marshal() ([]byte, error) {
	return proto.Marshal(c.data)
}

func (c *PlayerCommitment) Unmarshal(data []byte) error {
	c.data = &Player{}
	return proto.Unmarshal(data, c.data)
}

func init() {
	_PlayerSource.PKOf = func(obj interface{}) xdb.PK {
		r := obj.(*PlayerRecord)
		return &PlayerPK{
			PlayerId: r.PlayerId,
		}
	}
	xdb.RegisterSource(_PlayerSource)
}

// Field constants for Item
const (
	ItemFieldPlayerId xdb.Field = iota
	ItemFieldItemId
	ItemFieldCount
	ItemFieldCtime
	ItemFieldMtime
)

// ItemPK 主键
type ItemPK struct {
	PlayerId      int64
	ItemId        int32
	validFieldNum int
}

func (pk *ItemPK) Source() *xdb.Source {
	return _ItemSource
}

func (pk *ItemPK) String() string {
	return fmt.Sprintf("item:%v:%v",
		pk.PlayerId,
		pk.ItemId,
	)
}

func (pk *ItemPK) HashGroup() int {
	return int(pk.PlayerId % 16)
}

func (pk *ItemPK) Empty() bool {
	return pk.validFieldNum == 0
}

func (pk *ItemPK) PrefixOf(key xdb.Key) bool {
	_, ok := key.(*ItemPK)
	if !ok {
		return false
	}
	// TODO: 实现前缀匹配逻辑
	return false
}

func (pk *ItemPK) Full() bool {
	return pk.validFieldNum == 2
}

func (pk *ItemPK) FetchFilter() interface{} {
	filter := make(map[string]interface{})
	if pk.PlayerId != 0 {
		filter["player_id"] = pk.PlayerId
	}
	if pk.ItemId != 0 {
		filter["item_id"] = pk.ItemId
	}
	return filter
}

// ItemRecord 记录结构体
type ItemRecord struct {
	xdb.Header
	Item
}

func (r *ItemRecord) Source() *xdb.Source {
	return _ItemSource
}

func (r *ItemRecord) XId() string {
	return fmt.Sprintf("item:%v:%v",
		r.PlayerId,
		r.ItemId,
	)
}

func (r *ItemRecord) Lifecycle() xdb.Lifecycle {
	return r.Header.Lifecycle()
}

func (r *ItemRecord) Snapshoot() interface{} {
	return &r.Item
}

func (r *ItemRecord) XVersion() int64 {
	return 0
}

func (r *ItemRecord) GetHeader() *xdb.Header {
	return &r.Header
}

func (r *ItemRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(&r.Item)
}

func (r *ItemRecord) UnmarshalJSON(data []byte) error {
	return json.Unmarshal(data, &r.Item)
}

func (r *ItemRecord) String() string {
	return fmt.Sprintf("ItemRecord{%s:%v}", "player_id", r.PlayerId)
}

func (r *ItemRecord) Init(ctx context.Context, data interface{}) error {
	proto, ok := data.(*Item)
	if !ok {
		return fmt.Errorf("invalid data type")
	}
	r.Item = *proto
	r.Header.Init(xdb.LifecycleNew)
	return nil
}

func (r *ItemRecord) Update(ctx context.Context, changes interface{}, fs xdb.FieldSet) error {
	proto, ok := changes.(*Item)
	if !ok {
		return fmt.Errorf("invalid changes type")
	}
	if fs.Contains(ItemFieldPlayerId) {
		r.PlayerId = proto.PlayerId
	}
	if fs.Contains(ItemFieldItemId) {
		r.ItemId = proto.ItemId
	}
	if fs.Contains(ItemFieldCount) {
		r.Count = proto.Count
	}
	if fs.Contains(ItemFieldCtime) {
		r.Ctime = proto.Ctime
	}
	if fs.Contains(ItemFieldMtime) {
		r.Mtime = proto.Mtime
	}
	return nil
}

func (r *ItemRecord) Delete(ctx context.Context) bool {
	return r.Header.MarkAsDeleted(ctx)
}

func (r *ItemRecord) Commit(ctx context.Context) (xdb.Commitment, xdb.FieldSet) {
	commitment := &ItemCommitment{
		data:      &r.Item,
		changes:   r.Header.Changes(),
		lifecycle: r.Header.Lifecycle(),
	}
	return commitment, r.Header.Changes()
}

func (r *ItemRecord) Committing() bool {
	return r.Header.Committing()
}

func (r *ItemRecord) Dirty() bool {
	return r.Header.Dirty()
}

func (r *ItemRecord) SavingIndex() int32 {
	return r.Header.SavingIndex
}

func (r *ItemRecord) SetSavingIndex(idx int32) {
	r.Header.SavingIndex = idx
}

var _ItemSource = &xdb.Source{
	ProtoType:  reflect.TypeOf((*Item)(nil)).Elem(),
	RecordType: reflect.TypeOf((*ItemRecord)(nil)).Elem(),
	PKType:     reflect.TypeOf((*ItemPK)(nil)).Elem(),
	Namespace:  "item",
	DriverName: "none",
	TableName:  "item",
	KeySize:    2,

	PKCreator: func(args []interface{}) (xdb.PK, error) {
		if len(args) < 2 {
			return nil, fmt.Errorf("invalid args count")
		}
		return &ItemPK{
			PlayerId:      args[0].(int64),
			ItemId:        args[1].(int32),
			validFieldNum: 2,
		}, nil
	},

	PKOf: func(obj interface{}) xdb.PK {
		// 支持 Record 类型
		if r, ok := obj.(*ItemRecord); ok {
			return &ItemPK{
				PlayerId:      r.PlayerId,
				ItemId:        r.ItemId,
				validFieldNum: 2,
			}
		}
		// 支持 proto 类型
		if p, ok := obj.(*Item); ok {
			return &ItemPK{
				PlayerId:      p.PlayerId,
				ItemId:        p.ItemId,
				validFieldNum: 2,
			}
		}
		// 支持 Commitment 类型
		if c, ok := obj.(*ItemCommitment); ok {
			return &ItemPK{
				PlayerId:      c.data.PlayerId,
				ItemId:        c.data.ItemId,
				validFieldNum: 2,
			}
		}
		return nil
	},

	PKComparator: func(a, b interface{}) int {
		pk1 := a.(*ItemPK)
		pk2 := b.(*ItemPK)
		if pk1.PlayerId < pk2.PlayerId {
			return -1
		} else if pk1.PlayerId > pk2.PlayerId {
			return 1
		} else if pk1.ItemId < pk2.ItemId {
			return -1
		} else if pk1.ItemId > pk2.ItemId {
			return 1
		}
		return 0
	},

	CreateCommitment: func() xdb.Commitment {
		return &ItemCommitment{}
	},
}

// ItemCommitment 提交对象
type ItemCommitment struct {
	data      *Item
	changes   xdb.FieldSet
	lifecycle xdb.Lifecycle
}

func (c *ItemCommitment) Source() *xdb.Source {
	return _ItemSource
}

func (c *ItemCommitment) Merge(other xdb.Commitment) bool {
	otherC, ok := other.(*ItemCommitment)
	if !ok {
		return false
	}
	c.changes = c.changes.Union(otherC.changes)
	return true
}

func (c *ItemCommitment) Changes() xdb.FieldSet {
	return c.changes
}

func (c *ItemCommitment) PrepareWrite() (interface{}, interface{}) {
	return c.data, nil
}

func (c *ItemCommitment) Lifecycle() xdb.Lifecycle {
	return c.lifecycle
}

func (c *ItemCommitment) Marshal() ([]byte, error) {
	return proto.Marshal(c.data)
}

func (c *ItemCommitment) Unmarshal(data []byte) error {
	c.data = &Item{}
	return proto.Unmarshal(data, c.data)
}

func init() {
	_ItemSource.PKOf = func(obj interface{}) xdb.PK {
		r := obj.(*ItemRecord)
		return &ItemPK{
			PlayerId:      r.PlayerId,
			ItemId:        r.ItemId,
			validFieldNum: 2,
		}
	}
	xdb.RegisterSource(_ItemSource)
}
